from flask import Flask, render_template
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import io
import base64
import pyodbc
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import LabelEncoder
from pandas_datareader import data as pdr 
import yfinance as yf
import plotly.graph_objs as go 

app = Flask(__name__)

# Set the server, database, and driver details
server = 'DESKTOP-I0CJETN\SQLEXPRESS01'
database = 'araw'
driver = '{SQL Server}'

# Create the connection string with Windows Authentication
conn_str = f'DRIVER={driver};SERVER={server};DATABASE={database};Trusted_Connection=yes;'

# Connect to the SQL Server database
try:
    conn = pyodbc.connect(conn_str)
    print('Connection successful')
except pyodbc.Error as e:
    print(f'Error connecting to database: {e}')

yf.pdr_override()

# SQL query to select data from the table
sql_query = '''
SELECT *
FROM sales_data_sample
'''

# Read data from SQL server into a pandas dataframe
df = pd.read_sql_query(sql_query, conn)

# Print the dataframe
print(df.head())

# Define company details
company_name = 'ABC Corporation'
company_address = '123 Main Street, Anytown USA'
company_phone = '555-123-4567'
company_email = 'info@abccorp.com'
company_description = 'ABC Corporation is a leading provider of innovative solutions for businesses of all sizes.'
company_motive = 'Our mission is to empower businesses to achieve their full potential through our cutting-edge technology and exceptional customer service.'

@app.route('/')
def company_details():
    return render_template('company_details.html', 
                           name=company_name, 
                           address=company_address, 
                           phone=company_phone, 
                           email=company_email,
                           description=company_description,
                           motive=company_motive)

@app.route('/sales_data')
def plot_sales_data():

    # Total Sales
    total_sales = df['SALES'].sum()
    print(f"Total Sales: {total_sales}")

    # Average Order Size
    avg_order_size = df['QUANTITYORDERED'].mean()
    avg_order_size = round(avg_order_size, 2)
    print(f"Average Order Size: {avg_order_size}")

    # Number of Orders
    num_orders = len(df['ORDERNUMBER'].unique())
    print(f"Number of Orders: {num_orders}")

    # Total Sales by Product Line (using Plotly)
    sales_by_productline = df.groupby('PRODUCTLINE', as_index=False)['SALES'].sum()
    fig = px.bar(sales_by_productline, x='PRODUCTLINE', y='SALES', title='Sales w.r.t. Product Line')
    fig.update_layout(xaxis_title='Product Line', yaxis_title='Sales')
    plotly_image = fig.to_html(full_html=False)

    # Total Sales by Territory (using Matplotlib)
    exclude_territories = ['NA','79903','28023','530-0003','41101','EMEA','APAC','75012','N 0106','69004']
    sales_by_territory = df.groupby('TERRITORY', as_index=False)['SALES'].sum()
    sales_by_territory = sales_by_territory[~sales_by_territory['TERRITORY'].isin(exclude_territories)]  # exclude specified territories
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.bar(sales_by_territory['TERRITORY'], sales_by_territory['SALES'])
    ax.set_title('Total Sales by Territory')
    ax.set_xlabel('Territory')
    ax.set_ylabel('Sales')
    plt.xticks(rotation=90)
    plt.tight_layout()

    # Save plot to a bytes buffer and encode as base64
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    encoded_image = base64.b64encode(buffer.getvalue()).decode()

    return render_template('sales_data.html', title='Sales Data',name=company_name, total_sales=total_sales, avg_order_size=avg_order_size,
                           num_orders=num_orders, plotly_image=plotly_image, matplotlib_image=encoded_image)

@app.route('/customer_data')
def customer_data():

    # Number of Customers
    num_customers = len(df['CUSTOMERNAME'].unique())
    print(f"Number of Customers: {num_customers}")

    # Average Order Size
    avg_order_size = df['QUANTITYORDERED'].mean()
    avg_order_size = round(avg_order_size, 2)
    print(f"Average Order Size: {avg_order_size}")

    # Total Revenue by Customer
    revenue_by_customer = df.groupby('CUSTOMERNAME', as_index=False)['SALES'].sum()
    fig = px.bar(revenue_by_customer, x='CUSTOMERNAME', y='SALES', title='Revenue Generated by Each Customer')
    fig.update_layout(xaxis_title='Customer', yaxis_title='Revenue')
    plotly_image = fig.to_html(full_html=False)

    # Customer Segmentation by Country (using Matplotlib)
    exclude_countries = ['28034','3150','75016','80686','4101','3004','2067','1203','78000','8022','13008','59000','44000','71270','2','28023','21240','90110','67000','106-0032','2060','50739','60528']
    customer_by_country = df.groupby('COUNTRY', as_index=False)['CUSTOMERNAME'].nunique()
    customer_by_country = customer_by_country[~customer_by_country['COUNTRY'].isin(exclude_countries)]  # exclude specified territories
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.bar(customer_by_country['COUNTRY'], customer_by_country['CUSTOMERNAME'])
    ax.set_title('Number of Customers by Country')
    ax.set_xlabel('Country')
    ax.set_ylabel('Number of Customers')
    plt.xticks(rotation=90)
    plt.tight_layout()

    # Save plot to a bytes buffer and encode as base64
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    encoded_image = base64.b64encode(buffer.getvalue()).decode()

    return render_template('customer_data.html', title='Customer Analysis',name=company_name, num_customers=num_customers,
                           avg_order_size=avg_order_size, plotly_image=plotly_image, matplotlib_image=encoded_image)

@app.route('/product_data')
def product_analysis():
    # Number of Units Sold by Product
    units_sold = df.groupby('PRODUCTCODE')['QUANTITYORDERED'].sum().sort_values(ascending=False)
    fig1 = px.bar(units_sold, x=units_sold.index, y='QUANTITYORDERED', title='Number of Units Sold by Product')
    fig1.update_layout(xaxis_title='Product Code', yaxis_title='Units Sold')
    units_sold_plot = fig1.to_html(full_html=False)

    # Revenue Generated by Product
    revenue_by_product = df.groupby('PRODUCTCODE')['SALES'].sum().sort_values(ascending=False)
    fig2 = px.bar(revenue_by_product, x=revenue_by_product.index, y='SALES', title='Revenue Generated by Product')
    fig2.update_layout(xaxis_title='Product Code', yaxis_title='Revenue')
    revenue_plot = fig2.to_html(full_html=False)

    # Profit Margin by Product Line (using Matplotlib)
    profit_margin = (df['SALES'] - df['QUANTITYORDERED']*df['PRICEEACH']) / df['SALES']
    df['PROFIT_MARGIN'] = profit_margin
    profit_by_productline = df.groupby('PRODUCTLINE')['PROFIT_MARGIN'].mean().sort_values(ascending=False)
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.bar(profit_by_productline.index, profit_by_productline.values)
    ax.set_title('Profit Margin by Product Line')
    ax.set_xlabel('Product Line')
    ax.set_ylabel('Profit Margin')
    plt.xticks(rotation=45)
    plt.tight_layout()
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    profit_plot = base64.b64encode(buffer.getvalue()).decode()

    return render_template('product_analysis.html',title='Product Analysis',name=company_name, units_sold_plot=units_sold_plot, revenue_plot=revenue_plot, profit_plot=profit_plot)

@app.route('/sales_pred')
def plot_sales_prediction():

    # Drop irrelevant columns
    temp_df = df.drop(['ORDERNUMBER', 'PRICEEACH', 'ORDERLINENUMBER', 'STATUS', 'PRODUCTCODE', 'PHONE', 'ADDRESSLINE1', 'ADDRESSLINE2', 'CITY', 'STATE', 'POSTALCODE', 'TERRITORY', 'CONTACTLASTNAME', 'CONTACTFIRSTNAME', 'DEALSIZE'], axis=1)

    # Handle missing values
    temp_df = temp_df.dropna()

    # Encode categorical variables
    le = LabelEncoder()
    temp_df['PRODUCTLINE'] = le.fit_transform(temp_df['PRODUCTLINE'])
    temp_df['CUSTOMERNAME'] = le.fit_transform(temp_df['CUSTOMERNAME'])
    temp_df['COUNTRY'] = le.fit_transform(temp_df['COUNTRY'])

    # Split the data into training and testing sets
    X = temp_df[['YEAR_ID', 'MONTH_ID', 'QUANTITYORDERED']]
    y = temp_df['SALES']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Choose a machine learning algorithm
    model = LinearRegression()

    # Train the model
    model.fit(X_train, y_train)

    # Evaluate the model
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    rmse = mean_squared_error(y_test, y_pred, squared=False)
    r2 = r2_score(y_test, y_pred)

    # Visualize the results
    fig, ax = plt.subplots(figsize=(7.5, 6))
    ax.plot(X_test['YEAR_ID'], y_test, 'o', label='Actual')
    ax.plot(X_test['YEAR_ID'], y_pred, 'o', label='Predicted')
    ax.set_xlabel('Year')
    ax.set_ylabel('Sales')
    ax.legend()
    plt.xticks(rotation=90)
    plt.tight_layout()

    # Save plot to a bytes buffer and encode as base64
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    encoded_image = base64.b64encode(buffer.getvalue()).decode()

    # Make predictions
    new_data = pd.DataFrame({'YEAR_ID': [2006, 2007, 2008, 2009, 2010], 'MONTH_ID': [1, 2, 3, 4, 5], 'QUANTITYORDERED': [50, 60, 70, 80, 90]})
    new_data_pred = model.predict(new_data)

    # Visualize the results using Plotly
    fig = px.line(new_data, x='YEAR_ID', y=new_data_pred, title='Predicted Sales By Year')
    plotly_image = fig.to_html(full_html=False)

    # Render the template with the results
    return render_template('sales_pred.html', title='Sales Prediction', name=company_name,plotly_image=plotly_image,encoded_image=encoded_image,total_sales=df['SALES'].sum(),num_orders=len(df['ORDERNUMBER'].unique()))

# Route to display the stock price chart
@app.route('/stock_price')
def stock_price():
    stock="ABC"

    # Import the data frame (df) from yahoo finance using the specified stock as the ticker symbol
    df = yf.download(tickers=stock,period='1d',interval='1m')

    fig=go.Figure()

    fig.add_trace(go.Candlestick(x=df.index,
                    open=df['Open'],
                    high=df['High'],
                    low=df['Low'],
                    close=df['Close'], name = 'market data'))

    fig.update_layout(
        title= str(stock)+' Live Share Price:',
        yaxis_title='Stock Price (USD per Shares)')               

    fig.update_xaxes(
        rangeslider_visible=True,
        rangeselector=dict(
            buttons=list([
                dict(count=15, label="15m", step="minute", stepmode="backward"),
                dict(count=45, label="45m", step="minute", stepmode="backward"),
                dict(count=1, label="HTD", step="hour", stepmode="todate"),
                dict(count=3, label="3h", step="hour", stepmode="backward"),
                dict(step="all")
            ])
        )
    )

    # Convert the plot to an HTML div string
    plot_div = fig.to_html(full_html=False)

    # Create a new figure
    fig, ax = plt.subplots(figsize=(8, 6))
    # Plot the closing price as a line chart
    ax.plot(df.index, df['Close'])
    # Add labels and title
    ax.set_xlabel('Date')
    ax.set_ylabel('Closing Price (USD)')
    ax.set_title('Stock Price Chart')
    plt.xticks(rotation=90)
    plt.tight_layout()
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png')
    buffer.seek(0)
    stock_plot = base64.b64encode(buffer.getvalue()).decode()

    # Render the HTML template with the plot div
    return render_template('stock_price.html', plot_div=plot_div,stock_plot=stock_plot,title='Stock Price', name=company_name)

if __name__ == '__main__':
    app.run(debug=True)